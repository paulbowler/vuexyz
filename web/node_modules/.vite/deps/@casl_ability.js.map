{
  "version": 3,
  "sources": ["../../@ucast/core/src/Condition.ts", "../../@ucast/core/src/utils.ts", "../../@ucast/core/src/builder.ts", "../../@ucast/core/src/parsers/defaultInstructionParsers.ts", "../../@ucast/core/src/parsers/ObjectQueryParser.ts", "../../@ucast/core/src/interpreter.ts", "../../@ucast/core/src/translator.ts", "../../@ucast/core/src/index.ts", "../../@ucast/mongo/src/instructions.ts", "../../@ucast/mongo/src/MongoQueryParser.ts", "../../@ucast/mongo/src/index.ts", "../../@ucast/js/src/utils.ts", "../../@ucast/js/src/interpreter.ts", "../../@ucast/js/src/interpreters.ts", "../../@ucast/js/src/defaults.ts", "../../@ucast/mongo2js/src/factory.ts", "../../@casl/ability/src/utils.ts", "../../@casl/ability/src/Rule.ts", "../../@casl/ability/src/structures/LinkedItem.ts", "../../@casl/ability/src/RuleIndex.ts", "../../@casl/ability/src/PureAbility.ts", "../../@casl/ability/src/matchers/conditions.ts", "../../@casl/ability/src/matchers/field.ts", "../../@casl/ability/src/Ability.ts", "../../@casl/ability/src/AbilityBuilder.ts", "../../@casl/ability/src/ForbiddenError.ts"],
  "sourcesContent": ["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n", "import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n", "import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n", "import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n", "import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n", "import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n", "import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n", "import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n", "import {\n  CompoundCondition,\n  FieldCondition,\n  NamedInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n  DocumentInstruction,\n  Comparable,\n  ITSELF,\n  NULL_CONDITION,\n  FieldParsingContext,\n  optimizedCompoundCondition,\n  ObjectQueryFieldParsingContext,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nfunction ensureIsArray(instruction: NamedInstruction, value: unknown) {\n  if (!Array.isArray(value)) {\n    throw new Error(`\"${instruction.name}\" expects value to be an array`);\n  }\n}\n\nfunction ensureIsNonEmptyArray(instruction: NamedInstruction, value: unknown[]) {\n  ensureIsArray(instruction, value);\n\n  if (!value.length) {\n    throw new Error(`\"${instruction.name}\" expects to have at least one element in array`);\n  }\n}\n\nfunction ensureIsComparable(instruction: NamedInstruction, value: string | number | Date) {\n  const isComparable = typeof value === 'string' || typeof value === 'number' || value instanceof Date;\n\n  if (!isComparable) {\n    throw new Error(`\"${instruction.name}\" expects value to be comparable (i.e., string, number or date)`);\n  }\n}\n\nconst ensureIs = (type: string) => (instruction: NamedInstruction, value: unknown) => {\n  if (typeof value !== type) { // eslint-disable-line valid-typeof\n    throw new Error(`\"${instruction.name}\" expects value to be a \"${type}\"`);\n  }\n};\n\nexport const $and: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n  parse(instruction, queries, { parse }) {\n    const conditions = queries.map(query => parse(query));\n    return optimizedCompoundCondition(instruction.name, conditions);\n  }\n};\nexport const $or = $and;\nexport const $nor: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n};\n\nexport const $not: FieldInstruction<MongoQuery<any> | RegExp> = {\n  type: 'field',\n  validate(instruction, value) {\n    const isValid = value && (value instanceof RegExp || value.constructor === Object);\n\n    if (!isValid) {\n      throw new Error(`\"${instruction.name}\" expects to receive either regular expression or object of field operators`);\n    }\n  },\n  parse(instruction, value, context) {\n    const condition = value instanceof RegExp\n      ? new FieldCondition('regex' as typeof instruction.name, context.field, value)\n      : context.parse(value, context);\n\n    return new CompoundCondition(instruction.name, [condition]);\n  },\n};\nexport const $elemMatch: FieldInstruction<MongoQuery<any>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!value || value.constructor !== Object) {\n      throw new Error(`\"${instruction.name}\" expects to receive an object with nested query or field level operators`);\n    }\n  },\n  parse(instruction, value, { parse, field, hasOperators }) {\n    const condition = hasOperators(value) ? parse(value, { field: ITSELF }) : parse(value);\n    return new FieldCondition(instruction.name, field, condition);\n  }\n};\n\nexport const $size: FieldInstruction<number> = {\n  type: 'field',\n  validate: ensureIs('number')\n};\nexport const $in: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate: ensureIsArray,\n};\nexport const $nin = $in;\nexport const $all = $in;\nexport const $mod: FieldInstruction<[number, number]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value) || value.length !== 2) {\n      throw new Error(`\"${instruction.name}\" expects an array with 2 numeric elements`);\n    }\n  }\n};\n\nexport const $exists: FieldInstruction<boolean> = {\n  type: 'field',\n  validate: ensureIs('boolean'),\n};\n\nexport const $gte: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate: ensureIsComparable\n};\nexport const $gt = $gte;\nexport const $lt = $gt;\nexport const $lte = $gt;\n\nexport const $eq: FieldInstruction = {\n  type: 'field',\n};\nexport const $ne = $eq;\n\nexport interface RegExpFieldContext extends FieldParsingContext {\n  query: {\n    $options?: string\n  }\n}\n\nexport const $regex: FieldInstruction<string | RegExp, RegExpFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!(value instanceof RegExp) && typeof value !== 'string') {\n      throw new Error(`\"${instruction.name}\" expects value to be a regular expression or a string that represents regular expression`);\n    }\n  },\n  parse(instruction, rawValue, context) {\n    const value = typeof rawValue === 'string'\n      ? new RegExp(rawValue, context.query.$options || '')\n      : rawValue;\n    return new FieldCondition(instruction.name, context.field, value);\n  }\n};\nexport const $options: FieldInstruction = {\n  type: 'field',\n  parse: () => NULL_CONDITION,\n};\n\nexport const $where: DocumentInstruction<() => boolean> = {\n  type: 'document',\n  validate: ensureIs('function'),\n};\n", "import {\n  Condition,\n  buildAnd as and,\n  ParsingInstruction,\n  ObjectQueryParser,\n  FieldQueryOperators,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nexport interface ParseOptions {\n  field: string\n}\n\nexport class MongoQueryParser extends ObjectQueryParser<MongoQuery<any>> {\n  constructor(instructions: Record<string, ParsingInstruction>) {\n    super(instructions, {\n      defaultOperatorName: '$eq',\n      operatorToConditionName: name => name.slice(1),\n    });\n  }\n\n  parse<Q extends MongoQuery<any>, FQ extends FieldQueryOperators<Q> = FieldQueryOperators<Q>>(\n    query: Q | FQ,\n    options?: ParseOptions\n  ): Condition {\n    if (options && options.field) {\n      return and(this.parseFieldOperators(options.field, query as FQ));\n    }\n\n    return super.parse(query);\n  }\n}\n", "import * as instructions from './instructions';\n\nexport const allParsingInstructions = instructions;\nexport * from './instructions';\nexport * from './MongoQueryParser';\nexport * from './types';\nexport { defaultInstructionParsers as defaultParsers } from '@ucast/core';\n", "import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n", "import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n", "import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => !!value && value.hasOwnProperty(field) === node.value;\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n", "import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n", "import { createTranslatorFactory, ParsingInstruction, Condition, ITSELF } from '@ucast/core';\nimport {\n  MongoQuery,\n  MongoQueryParser,\n  MongoQueryFieldOperators,\n  allParsingInstructions,\n  defaultParsers\n} from '@ucast/mongo';\nimport {\n  createJsInterpreter,\n  allInterpreters,\n  JsInterpreter,\n  JsInterpretationOptions,\n  compare\n} from '@ucast/js';\n\ntype ThingFilter<T> = {\n  (object: T): boolean\n  ast: Condition\n};\n\ninterface HasToJSON {\n  toJSON(): unknown\n}\n\nfunction toPrimitive(value: unknown) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  if (value && typeof (value as HasToJSON).toJSON === 'function') {\n    return (value as HasToJSON).toJSON();\n  }\n\n  return value;\n}\n\nconst comparePrimitives: typeof compare = (a, b) => compare(toPrimitive(a), toPrimitive(b));\n\nexport interface FactoryOptions extends JsInterpretationOptions {\n  forPrimitives: boolean\n}\n\nexport type Filter = <\n  T = Record<string, unknown>,\n  Q extends MongoQuery<T> = MongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\nexport type PrimitiveMongoQuery<T> = MongoQueryFieldOperators<T> & Partial<{\n  $and: MongoQueryFieldOperators<T>[],\n  $or: MongoQueryFieldOperators<T>[],\n  $nor: MongoQueryFieldOperators<T>[]\n}>;\nexport type PrimitiveFilter = <\n  T,\n  Q extends PrimitiveMongoQuery<T> = PrimitiveMongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\ntype FilterType<T extends { forPrimitives?: true }> = T['forPrimitives'] extends true\n  ? PrimitiveFilter\n  : Filter;\n\nexport function createFactory<\n  T extends Record<string, ParsingInstruction<any, any>>,\n  I extends Record<string, JsInterpreter<any>>,\n  P extends { forPrimitives?: true }\n>(instructions: T, interpreters: I, options?: Partial<FactoryOptions> & P): FilterType<P> {\n  const parser = new MongoQueryParser(instructions);\n  const interpret = createJsInterpreter(interpreters, {\n    compare: comparePrimitives,\n    ...options\n  });\n\n  if (options && options.forPrimitives) {\n    const params = { field: ITSELF };\n    const parse = parser.parse;\n    parser.setParse(query => parse(query, params));\n  }\n\n  return createTranslatorFactory(parser.parse, interpret) as any;\n}\n\nexport const guard = createFactory(allParsingInstructions, allInterpreters);\n\nconst compoundOperators = ['$and', '$or'] as const;\nconst allPrimitiveParsingInstructions = compoundOperators.reduce((instructions, name) => {\n  instructions[name] = { ...instructions[name], type: 'field' } as any;\n  return instructions;\n}, {\n  ...allParsingInstructions,\n  $nor: {\n    ...allParsingInstructions.$nor,\n    type: 'field',\n    parse: defaultParsers.compound\n  }\n});\n\nexport const squire = createFactory(allPrimitiveParsingInstructions, allInterpreters, {\n  forPrimitives: true\n});\nexport const filter = guard; // TODO: remove in next major version\n", "import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst hasOwnProperty = (Object as any).hasOwn\n  || Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!hasOwnProperty(object, TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject: Exclude<Subject, SubjectType>): string {\n  if (hasOwnProperty(subject, TYPE_FIELD)) {\n    return subject[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (hasOwnProperty(aliasMap, action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n", "import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n", "export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n", "import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\nexport declare const \u0275abilities: unique symbol;\nexport declare const \u0275conditions: unique symbol;\ninterface WithGenerics {\n  [\u0275abilities]: any\n  [\u0275conditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof \u0275abilities],\n  conditions: T[typeof \u0275conditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\nconst analyze = (index: any, rule: Rule<any, any>) => {\n  if (!index._hasPerFieldRules && rule.fields) {\n    index._hasPerFieldRules = true;\n  }\n};\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events: Events<this> = new Map();\n  private _indexedRules!: IndexTree<A, Conditions>;\n  private _rules!: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions!: RuleOptions<Conditions>;\n  private readonly _detectSubjectType!: Required<RuleIndexOptions<A, Conditions>>['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  readonly [\u0275abilities]!: A;\n  readonly [\u0275conditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._detectSubjectType = options.detectSubjectType || detectSubjectType;\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object;\n    if (!object) return this._anySubjectType;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      analyze(this, rule);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[]\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[]\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    const tail = this._events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    this._events.set(event, item);\n\n    return () => {\n      const currentTail = this._events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        this._events.delete(event);\n      } else if (item === currentTail) {\n        this._events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n", "import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\n\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport type CreateAbility<T extends AnyAbility> = (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean\n  can(action: string, subject?: Subject, field?: string): boolean {\n    const rule = (this as PrimitiveAbility).relevantRuleFor(action, subject, field);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean\n  cannot(action: string, subject?: Subject, field?: string): boolean {\n    return !(this as PrimitiveAbility).can(action, subject, field);\n  }\n}\n\n/**\n * helper interface that helps to emit js methods that have static parameters\n */\ninterface PrimitiveAbility<A extends Abilities = AbilityTuple, Conditions = unknown> {\n  can(action: string, subject?: Subject, field?: string): boolean;\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null\n}\n", "import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n", "import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n", "import { PureAbility, AbilityOptions, AbilityOptionsOf } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public, RawRuleOf } from './RuleIndex';\n\n/**\n * @deprecated use createMongoAbility function instead and MongoAbility<Abilities> interface.\n * In the next major version PureAbility will be renamed to Ability and this class will be removed\n */\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<PureAbility<any, MongoQuery>> {}\nexport interface MongoAbility<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {}\n\nexport function createMongoAbility<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n>(rules?: RawRuleFrom<A, C>[], options?: AbilityOptions<A, C>): MongoAbility<A, C>;\nexport function createMongoAbility<\n  T extends AnyMongoAbility = AnyMongoAbility\n>(rules?: RawRuleOf<T>[], options?: AbilityOptionsOf<T>): T;\nexport function createMongoAbility(rules: any[] = [], options = {}): AnyMongoAbility {\n  return new PureAbility(rules, {\n    conditionsMatcher: mongoQueryMatcher,\n    fieldMatcher: fieldPatternMatcher,\n    ...options,\n  });\n}\n", "import { AnyMongoAbility, createMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  TaggedInterface,\n  Normalize,\n  AnyObject,\n  AnyClass,\n} from './types';\nimport { ProduceGeneric } from './hkt';\n\nfunction isAbilityClass(factory: AbilityFactory<any>): factory is AnyClass {\n  return typeof factory.prototype.possibleRulesFor === 'function';\n}\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype AbilityFactory<T extends AnyAbility> = AnyClass<T> | ((rules?: any[], options?: any) => T);\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends (...args: any[]) => infer O\n    ? O\n    : S extends string\n      ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n        ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n        : AnyObject\n      : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends T[1] ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private readonly _createAbility: AbilityFactory<T>;\n\n  constructor(AbilityType: AbilityFactory<T>) {\n    this._createAbility = AbilityType;\n    this.can = this.can.bind(this as any);\n    this.cannot = this.cannot.bind(this as any);\n    this.build = this.build.bind(this as any);\n  }\n\n  can<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  can<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions']\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  cannot<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<T> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder._rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>) {\n    return isAbilityClass(this._createAbility)\n      ? new this._createAbility(this.rules, options)\n      : this._createAbility(this.rules, options);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder<T>(createMongoAbility);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n", "import { AnyAbility } from './PureAbility';\nimport { Normalize, Subject } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\n/** @deprecated will be removed in the next major release */\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U): ForbiddenError<U> {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string): this {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>): void\n  throwUnlessCan(action: string, subject?: Subject, field?: string): void {\n    const error = (this as any).unlessCan(action, subject, field);\n    if (error) throw error;\n  }\n\n  unlessCan(...args: Parameters<T['can']>): this | undefined\n  unlessCan(action: string, subject?: Subject, field?: string): this | undefined {\n    const rule = this.ability.relevantRuleFor(action, subject, field);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = action;\n    this.subject = subject;\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(subject));\n    this.field = field;\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    return this; // eslint-disable-line consistent-return\n  }\n}\n"],
  "mappings": "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",
  "names": ["Condition", "operator", "value", "Object", "defineProperty", "this", "writable", "n", "i", "e", "r", "addNote", "note", "_notes", "push", "DocumentCondition", "CompoundCondition", "conditions", "Array", "isArray", "Error", "_DocumentCondition", "ITSELF", "FieldCondition", "field", "NULL_CONDITION", "hasOwnProperty", "prototype", "call", "bind", "isCompound", "condition", "optimizedCompoundCondition", "length", "flattenConditions", "aggregatedResult", "flatConditions", "currentNode", "identity", "x", "object", "create", "ignoreValue", "hasOperators", "instructions", "skipIgnore", "constructor", "prop", "objectKeysSkipIgnore", "anyObject", "keys", "key", "pushIfNonNullCondition", "buildAnd", "condition", "defaultInstructionParsers", "compound", "instruction", "value", "context", "conditions", "Array", "isArray", "map", "query", "parse", "CompoundCondition", "name", "field", "FieldCondition", "document", "DocumentCondition", "ObjectQueryParser", "instructions", "options", "object", "_instructions", "_fieldInstructionContext", "_documentInstructionContext", "_options", "_objectKeys", "this", "bind", "operatorToConditionName", "identity", "defaultOperatorName", "mergeFinalConditions", "buildAnd", "Object", "keys", "reduce", "all", "_this", "fieldContext", "hasOperators", "useIgnoreValue", "documentContext", "objectKeysSkipIgnore", "setParse", "parseField", "operator", "parentQuery", "Error", "type", "parseInstruction", "validate", "parseFieldOperators", "i", "length", "op", "pushIfNonNullCondition", "key", "push", "getInterpreter", "interpreters", "interpret", "defaultInterpreterName", "createInterpreter", "rawOptions", "getInterpreterName", "numberOfArguments", "interpreterName", "defaultContext", "params", "createTranslatorFactory", "args", "ast", "translate", "prototype", "ensureIsArray", "instruction", "value", "Array", "isArray", "Error", "name", "ensureIsNonEmptyArray", "length", "ensureIs", "type", "$and", "validate", "parse", "queries", "conditions", "map", "query", "optimizedCompoundCondition", "$or", "$nor", "$not", "RegExp", "constructor", "Object", "context", "condition", "FieldCondition", "field", "CompoundCondition", "$elemMatch", "hasOperators", "ITSELF", "$size", "$in", "$nin", "$all", "$mod", "$exists", "$gte", "Date", "$gt", "$lt", "$lte", "$eq", "$ne", "$regex", "rawValue", "$options", "NULL_CONDITION", "$where", "p", "s", "l", "d", "v", "w", "y", "x", "h", "m", "g", "b", "E", "j", "_", "q", "MongoQueryParser", "instructions", "_ObjectQueryParser", "defaultOperatorName", "operatorToConditionName", "slice", "r", "e", "t", "n", "options", "and", "this", "parseFieldOperators", "ObjectQueryParser", "allParsingInstructions", "includes", "items", "value", "compare", "i", "length", "isArrayAndNotNumericField", "object", "field", "Array", "isArray", "Number", "isNaN", "getField", "get", "result", "concat", "testValueOrArray", "test", "node", "context", "some", "v", "defaultGet", "getObjectFieldCursor", "path", "dotIndex", "lastIndexOf", "slice", "getObjectField", "ITSELF", "Error", "String", "indexOf", "paths", "split", "compare", "a", "b", "createJsInterpreter", "operators", "options", "createInterpreter", "get", "getObjectField", "or", "node", "object", "interpret", "value", "some", "condition", "nor", "context", "and", "every", "not", "eq", "field", "Array", "isArray", "includes", "ne", "lte", "testValueOrArray", "result", "lt", "gt", "gte", "exists", "ITSELF", "getObjectFieldCursor", "item", "test", "hasOwnProperty", "isArrayAndNotNumericField", "mod", "size", "items", "length", "regex", "within", "nin", "all", "v", "elemMatch", "where", "call", "allInterpreters", "in", "interpreters", "toPrimitive", "value", "Date", "getTime", "toJSON", "comparePrimitives", "a", "b", "compare", "createFactory", "instructions", "interpreters", "options", "parser", "MongoQueryParser", "interpret", "createJsInterpreter", "forPrimitives", "params", "field", "ITSELF", "parse", "setParse", "query", "createTranslatorFactory", "guard", "allParsingInstructions", "allInterpreters", "squire", "reduce", "name", "type", "$nor", "defaultParsers", "compound", "wrapArray", "value", "Array", "isArray", "hasOwnProperty", "Object", "hasOwn", "prototype", "call", "bind", "TYPE_FIELD", "setSubjectType", "type", "object", "defineProperty", "Error", "isSubjectType", "getSubjectClassName", "modelName", "name", "getSubjectTypeName", "detectSubjectType", "subject", "constructor", "expandActions", "aliasMap", "rawActions", "merge", "actions", "i", "length", "action", "findDuplicate", "actionToFind", "indexOf", "defaultAliasMerge", "concat", "validateForCycles", "reservedAction", "keys", "mergeAliasesAndDetectCycles", "duplicate", "join", "isUsingReservedAction", "createAliasResolver", "options", "skipValidate", "anyAction", "copyArrayTo", "dest", "target", "start", "push", "mergePrioritized", "array", "anotherArray", "j", "merged", "priority", "getOrDefault", "map", "key", "defaultValue", "get", "set", "identity", "x", "validate", "rule", "fields", "fieldMatcher", "conditions", "conditionsMatcher", "Rule", "resolveAction", "inverted", "reason", "undefined", "_options", "_conditionsMatcher", "t", "this", "_matchConditions", "matchesConditions", "matches", "matchesField", "field", "_matchField", "ast", "linkedItem", "prev", "item", "next", "unlinkItem", "cloneLinkedItem", "defaultActionEntry", "rules", "defaultSubjectEntry", "Map", "analyze", "index", "_hasPerFieldRules", "RuleIndex", "_events", "_ruleOptions", "_anyAction", "_anySubjectType", "anySubjectType", "_detectSubjectType", "_rules", "_indexedRules", "_buildIndexFor", "update", "event", "ability", "_emit", "rawRules", "indexedRules", "subjects", "k", "subjectRules", "possibleRulesFor", "subjectType", "actionRules", "anyActionRules", "has", "rulesFor", "filter", "on", "handler", "tail", "currentTail", "_this", "delete", "payload", "current", "PureAbility", "can", "relevantRuleFor", "r", "cannot", "defaultInstructions", "$eq", "$ne", "$lt", "$lte", "$gt", "$gte", "$in", "$nin", "$all", "$size", "$regex", "$options", "$elemMatch", "$exists", "defaultInterpreters", "eq", "ne", "lt", "lte", "gt", "gte", "in", "within", "nin", "all", "size", "regex", "elemMatch", "exists", "and", "buildMongoQueryMatcher", "instructions", "interpreters", "createFactory", "mongoQueryMatcher", "REGEXP_SPECIAL_CHARS", "REGEXP_ANY", "REGEXP_STARS", "REGEXP_DOT", "detectRegexpPattern", "match", "string", "quantifier", "matcher", "pattern", "replace", "escapeRegexp", "createPattern", "patterns", "RegExp", "fieldPatternMatcher", "every", "f", "test", "Ability", "_PureAbility", "createMongoAbility", "isAbilityClass", "factory", "RuleBuilder", "_rule", "because", "AbilityBuilder", "AbilityType", "_createAbility", "build", "conditionsOrFields", "builder", "defineAbility", "define", "result", "then", "getDefaultErrorMessage", "error", "NativeError", "NError", "message", "create", "ForbiddenError", "setDefaultMessage", "messageOrFn", "_defaultErrorMessage", "from", "captureStackTrace", "setMessage", "throwUnlessCan", "unlessCan"]
}
